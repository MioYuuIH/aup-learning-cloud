<!-- Modifications Copyright (C) 2025 Advanced Micro Devices, Inc. All rights reserved.
 Portions of this file consist of AI-generated content. -->
<!--
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->



<!-- Dockerfile/Hub/templates/resource_options_form.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Resource Selection</title>

<style>
    @media (prefers-color-scheme: dark) {
        .resource-container {
            background: var(--jp-layout-color1) !important;
            border-color: var(--jp-border-color1) !important;
        }
        .resource-container h5,
        .resource-container strong {
            color: var(--jp-ui-font-color0) !important;
        }
        .resource-container .env-desc {
            color: var(--jp-ui-font-color1) !important;
        }
        .resource-container .dot {
            color: var(--jp-ui-font-color2) !important;
        }
        .resource-container .resource-tag {
            color: var(--jp-warn-color0) !important;
            background: var(--jp-warn-color3) !important;
            border-color: var(--jp-warn-color2) !important;
        }
        .resource-container input[type="number"] {
            background: var(--jp-layout-color1) !important;
            color: var(--jp-ui-font-color1) !important;
            border-color: var(--jp-border-color1) !important;
        }
        .gpu-selection {
            background: var(--jp-layout-color1) !important;
            border-color: var(--jp-border-color1) !important;
        }
        .gpu-option {
            background: var(--jp-layout-color0) !important;
            border-color: var(--jp-border-color1) !important;
        }
        .resource-category-header {
            color: var(--jp-ui-font-color0) !important;
            background: var(--jp-layout-color2) !important;
            border-color: var(--jp-border-color1) !important;
        }
        .collapsible-content {
            background: var(--jp-layout-color1) !important;
        }
    }
    
    .gpu-selection {
        margin-top: 15px;
        margin-left: 40px;
        padding: 18px;
        background: #ffffff;
        border: 1px solid #e5e9f0;
        border-radius: 12px;
        display: none;
        box-shadow: 0 3px 8px rgba(0,0,0,0.06);
    }
    
    .gpu-options-container {
        max-height: 180px; /* Height for approximately 3 options */
        overflow-y: auto;
        padding-right: 5px;
    }
    
    /* Scrollbar styling */
    .gpu-options-container::-webkit-scrollbar {
        width: 6px;
    }
    
    .gpu-options-container::-webkit-scrollbar-track {
        background: #f1f1f1;
        border-radius: 10px;
    }
    
    .gpu-options-container::-webkit-scrollbar-thumb {
        background: #c1c9d6;
        border-radius: 10px;
    }
    
    .gpu-options-container::-webkit-scrollbar-thumb:hover {
        background: #a1aebf;
    }
    
    .gpu-selection h6 {
        color: #2e3440;
        font-size: 1rem;
        margin-bottom: 16px;
        padding-bottom: 10px;
        border-bottom: 2px solid #ebecf0;
        font-weight: 600;
        position: relative;
    }
    
    .gpu-selection h6::after {
        content: '';
        position: absolute;
        bottom: -2px;
        left: 0;
        width: 60px;
        height: 2px;
        background: #5e81ac;
    }
    
    .gpu-option {
        margin: 10px 0;
        padding: 14px 16px;
        background: #f8f9fc;
        border: 1px solid #e5e9f0;
        border-radius: 10px;
        display: flex;
        align-items: center;
        cursor: pointer;
        position: relative;
        overflow: hidden;
    }
    
    .gpu-option:hover {
        background: #eceff4;
        border-color: #5e81ac;
    }
    
    .gpu-option:active {
        transform: translateY(0);
    }
    
    .gpu-option input[type="radio"] {
        margin-right: 12px;
        width: 18px;
        height: 18px;
        accent-color: #5e81ac;
    }
    
    .gpu-option-details {
        flex: 1;
    }
    
    .gpu-option-name {
        font-weight: 600;
        color: #2e3440;
        margin-bottom: 4px;
        font-size: 0.95rem;
    }
    
    .gpu-option-desc {
        font-size: 0.85rem;
        color: #4c566a;
        line-height: 1.4;
    }
    
    .gpu-option.selected {
        background: #e5e9f0;
        border-color: #5e81ac;
        box-shadow: 0 0 0 1px #5e81ac;
    }

    .loading {
        text-align: center;
        padding: 40px;
        color: #4c566a;
    }

    .spinner {
        display: inline-block;
        width: 24px;
        height: 24px;
        border: 3px solid #e5e9f0;
        border-radius: 50%;
        border-top-color: #5e81ac;
        animation: spin 1s ease-in-out infinite;
        margin-right: 12px;
    }
    
    /* Collapsible section styles */
    .resource-category {
        margin-bottom: 20px;
        border: 1px solid #e0e0e0;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
    
    .resource-category:hover {
        box-shadow: 0 2px 5px rgba(0,0,0,0.08);
    }
    
    .resource-category-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 20px;
        background: #f8f9fa;
        cursor: pointer;
        border-bottom: 1px solid #e0e0e0;
    }
    
    .resource-category-header:hover {
        background: linear-gradient(to right, #eef1f5, #e8ecf2);
    }
    
    .resource-category-header h5 {
        margin: 0;
        color: #2c3e50;
        font-size: 16px;
        font-weight: 600;
        display: flex;
        align-items: center;
    }
    
    /* Removed bullet point
    .resource-category-header h5::before {
        content: '';
        display: inline-block;
        width: 6px;
        height: 6px;
        border-radius: 50%;
        margin-right: 10px;
        background-color: #5e81ac;
    }
    */
    
    .collapse-icon {
        font-size: 16px;
        transition: transform 0.2s ease;
        color: #5e81ac;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .collapsed .collapse-icon {
        transform: rotate(-90deg);
    }
    
    .collapsible-content {
        max-height: 1000px;
        overflow: hidden;
        transition: max-height 0.2s ease-out, padding 0.2s ease-out;
        background: #ffffff;
        padding: 20px;
    }
    
    .collapsed .collapsible-content {
        max-height: 0;
        padding: 0;
        border-top: none;
    }

    @keyframes spin {
        to { transform: rotate(360deg); }
    }
    
    /* Scroll to bottom button styles */
    .scroll-to-bottom {
        position: fixed;
        bottom: 20px;
        right: 20px;
        width: 50px;
        height: 50px;
        background-color: #5e81ac;
        color: white;
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s, visibility 0.3s;
        z-index: 1000;
    }
    
    .scroll-to-bottom:hover {
        background-color: #4c6c94;
    }
    
    .scroll-to-bottom.visible {
        opacity: 1;
        visibility: visible;
    }
</style>
</head>
<body>

<div id="loading" class="loading">
    <div class="spinner"></div>
    Loading available resources...
</div>

<div id="resourceForm" class="resource-container" style="max-width: 1000px; margin: 0 auto; padding: 25px; background: #f8f9fa; border-radius: 16px; display: none; box-shadow: 0 2px 6px rgba(0,0,0,0.05);">

    <!-- Quota Balance Display (hidden, used for data only) -->
    <div id="quotaBalanceContainer" style="display: none;">
        <span id="quotaBalance">0</span>
    </div>

    <!-- Insufficient Quota Warning -->
    <div id="insufficientQuotaWarning" style="display: none; padding: 15px 20px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px; color: #856404; margin-bottom: 20px;">
        <strong>Insufficient Quota</strong><br>
        You don't have enough quota to start a container. Please contact administrator.
    </div>

    <div id="resourceList">
        <!-- Resources will be dynamically loaded here -->
    </div>
    
    <div id="noResources" style="padding: 20px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 8px; color: #856404; display: none;">
        <strong>No resources available</strong><br>
        Please contact administrator for access.
    </div>
    
    <div id="runtimeContainer" style="margin-top: 30px; padding-top: 25px; border-top: 1px solid #e0e0e0; display: flex; align-items: center; flex-wrap: wrap;">
        <label for="runtime" style="color: #2c3e50; margin-right: 15px; font-weight: 500;">Run my server for (minutes):</label>
        <input name="runtime"
               id="runtimeInput"
               type="number"
               min="10"
               value="20"
               max="240"
               step="5"
               style="width: 120px; padding: 10px 12px; border: 1px solid #d0d7de; border-radius: 8px; font-size: 14px; color: #2c3e50; box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); transition: all 0.2s ease;"
               onFocus="this.style.borderColor='#5e81ac'; this.style.boxShadow='0 0 0 3px rgba(94, 129, 172, 0.2)';"
               onBlur="this.style.borderColor='#d0d7de'; this.style.boxShadow='inset 0 1px 2px rgba(0,0,0,0.05)';"
               oninput="updateQuotaCostPreview();"/>
        <!-- Quota Cost Preview -->
        <div id="quotaCostPreview" style="display: none; margin-left: 20px; font-size: 14px;">
            <span style="color: #666;">Estimated cost:</span>
            <strong id="estimatedCost" style="color: #2e7d32;">0</strong>
            <span style="color: #666;"> quota (Remaining: </span>
            <strong id="remainingQuota" style="color: #2e7d32;">0</strong>
            <span style="color: #666;">)</span>
        </div>
    </div>

    <div style="margin-top: 25px; display: flex; align-items: center; gap: 20px;">
        <input type="submit" id="startButton" value="Launch" class="btn btn-jupyter form-control" style="padding: 10px 20px; font-weight: 500; transition: all 0.2s ease; border-radius: 8px; opacity: 0.5; cursor: not-allowed; flex: 0 0 auto; width: auto;" disabled>
        <!-- Simple Quota Display next to Launch button -->
        <div id="quotaDisplaySimple" style="display: none; font-size: 14px; color: #666;">
            Quota: <strong id="quotaBalanceSimple" style="color: #5e81ac;">0</strong>
        </div>
    </div>
</div>

<!-- Scroll to bottom button -->
<div id="scrollToBottom" class="scroll-to-bottom">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="6 9 12 15 18 9"></polyline>
    </svg>
</div>

<script>
// ============ Quota System ============
let userQuotaInfo = {
    balance: 0,
    rates: {},
    accelerators: {},  // Accelerator options from backend
    enabled: false
};
let selectedResourceType = null;
let selectedAcceleratorType = 'cpu';  // Track selected GPU/accelerator type for quota calculation

// Get XSRF token from cookie (required for JupyterHub API calls)
function getXsrfToken() {
    const match = document.cookie.match(/(?:^|;\s*)_xsrf=([^;]+)/);
    return match ? decodeURIComponent(match[1]) : '';
}

// Fetch user's quota information and accelerator config
async function fetchUserQuota() {
    try {
        const headers = { 'X-XSRFToken': getXsrfToken() };
        // Fetch quota info and accelerators in parallel
        const [quotaResponse, acceleratorsResponse] = await Promise.all([
            fetch('/hub/api/quota/me', { headers }),
            fetch('/hub/api/accelerators', { headers })
        ]);

        if (quotaResponse.ok) {
            userQuotaInfo = await quotaResponse.json();
        }

        // Merge accelerators from separate endpoint
        if (acceleratorsResponse.ok) {
            const acceleratorsData = await acceleratorsResponse.json();
            userQuotaInfo.accelerators = acceleratorsData.accelerators || {};
        }

        displayQuotaBalance();
        return userQuotaInfo;
    } catch (e) {
        console.log('Quota system not available or disabled');
    }
    return null;
}

// Display quota balance in the header
function displayQuotaBalance() {
    if (!userQuotaInfo.enabled) {
        return;
    }

    const container = document.getElementById('quotaBalanceContainer');
    const balanceEl = document.getElementById('quotaBalance');
    const costPreview = document.getElementById('quotaCostPreview');
    const simpleDisplay = document.getElementById('quotaDisplaySimple');
    const simpleBalanceEl = document.getElementById('quotaBalanceSimple');

    if (balanceEl) {
        // Update hidden balance element (for data)
        if (userQuotaInfo.unlimited) {
            balanceEl.textContent = 'Unlimited';
        } else {
            balanceEl.textContent = userQuotaInfo.balance;
        }
    }

    // Show simple quota display next to Launch button
    if (simpleDisplay && simpleBalanceEl) {
        if (userQuotaInfo.unlimited) {
            simpleBalanceEl.textContent = 'Unlimited';
            simpleBalanceEl.style.color = '#28a745';
        } else {
            simpleBalanceEl.textContent = userQuotaInfo.balance;
            simpleBalanceEl.style.color = userQuotaInfo.balance < 10 ? '#dc3545' : '#5e81ac';
        }
        simpleDisplay.style.display = 'inline';
    }

    // Only show cost preview for non-unlimited users
    if (costPreview && !userQuotaInfo.unlimited) {
        costPreview.style.display = 'inline';
    }

    // Show warning if balance is too low (only for non-unlimited users)
    if (!userQuotaInfo.unlimited && userQuotaInfo.balance < 10) {
        const warning = document.getElementById('insufficientQuotaWarning');
        if (warning) {
            warning.style.display = 'block';
        }
    }

    updateQuotaCostPreview();
}

// Update the cost preview when runtime or resource changes
function updateQuotaCostPreview() {
    if (!userQuotaInfo.enabled || userQuotaInfo.unlimited) {
        return;
    }

    const runtimeInput = document.getElementById('runtimeInput');
    const estimatedCostEl = document.getElementById('estimatedCost');
    const remainingQuotaEl = document.getElementById('remainingQuota');

    if (!runtimeInput || !estimatedCostEl || !remainingQuotaEl) {
        return;
    }

    const minutes = parseInt(runtimeInput.value) || 20;
    // Use accelerator type (gpu_selection) for rate lookup, not resource type
    const rate = userQuotaInfo.rates[selectedAcceleratorType] || userQuotaInfo.rates['cpu'] || 1;
    const cost = rate * minutes;
    const remaining = userQuotaInfo.balance - cost;

    estimatedCostEl.textContent = cost;
    remainingQuotaEl.textContent = remaining;

    // Update colors based on whether user can afford it
    if (remaining < 0) {
        estimatedCostEl.style.color = '#c62828';
        remainingQuotaEl.style.color = '#c62828';
    } else {
        estimatedCostEl.style.color = '#2e7d32';
        remainingQuotaEl.style.color = '#2e7d32';
    }

    // Update max runtime based on balance
    if (rate > 0 && userQuotaInfo.balance > 0) {
        const maxAffordable = Math.floor(userQuotaInfo.balance / rate);
        runtimeInput.max = Math.min(240, maxAffordable);
    }
}

// Called when a resource is selected
function onResourceSelected(resourceType) {
    selectedResourceType = resourceType;
    updateQuotaCostPreview();
}

// Get accelerator info from backend API (via userQuotaInfo.accelerators)
// This replaces hardcoded GPU_NODE_OPTIONS
function getAcceleratorInfo(key) {
    const acc = userQuotaInfo.accelerators?.[key];
    if (acc) {
        return {
            name: key,
            display_name: acc.displayName || key,
            description: acc.description || '',
            node_selector: acc.nodeSelector || {},
            env: acc.env || {},
            quota_rate: acc.quotaRate || 1
        };
    }
    // Fallback for unknown accelerators
    return { name: key, display_name: key, description: '', node_selector: {}, env: {}, quota_rate: 1 };
}

// Build GPU options object for specified accelerator keys
function buildGpuOptions(keys) {
    const options = {};
    for (const key of keys) {
        options[key] = getAcceleratorInfo(key);
    }
    return options;
}

// Predefined accelerator groups (which accelerators are available for each type)
const GPU_ACCELERATORS = ["phx", "strix", "strix-halo", "dgpu"];
const GFX1151_ACCELERATORS = ["strix-halo"];
const NPU_ACCELERATORS = ["strix-npu"];

const RESOURCE_SPECS = {
        "cpu": {
            "name": "cpu",
            "group": "OTHERS", 
            "description": "Basic Python Environment",
            "sub_description": "CPU Only Environment",
            "cpu": "2",
            "memory": "4Gi",
            "accelerator": "CPU",
            "image": "ghcr.io/amdresearch/aup-cpu-notebook:v1.0"
        },
        // "mlir-aie": {
        //     "name": "mlir-aie",
        //     "group": "OTHERS", 
        //     "description": "IRON NPU Compiler (Alpha Test)",
        //     "sub_description": "Suitable for advanced AIE applications",
        //     "cpu": "4",
        //     "memory": "8Gi",
        //     "accelerator": "NPU",
        //     "image": "ghcr.io/amdresearch/aup-mliraie-notebook:v1.0",
        //     "accelerator_keys": NPU_ACCELERATORS
        // },
        "Course-CV": {
            "name": "Course-CV",
            "group": "COURSE", 
            "description": "Computer Vision Course",
            "sub_description": "Suitable for CV experiments with GPU",
            "cpu": "4",
            "memory": "16Gi",
            "accelerator": "GPU",
            "image": "ghcr.io/amdresearch/aup-course-cv:v1.3.1-TheRock",
            "accelerator_keys": GFX1151_ACCELERATORS
        },
        "Course-DL": {
            "name": "Course-DL",
            "group": "COURSE", 
            "description": "Deep Learning Course",
            "sub_description": "Suitable for DL experiments with GPU",
            "cpu": "4",
            "memory": "16Gi",
            "accelerator": "GPU",
            "image": "ghcr.io/amdresearch/aup-course-dl:v1.3.1-TheRock",
            "accelerator_keys": GFX1151_ACCELERATORS
        },
        "Course-LLM": {
            "name": "Course-LLM",
            "group": "COURSE", 
            "description": "Large Language Models Course",
            "sub_description": "Suitable for LLM experiments with GPU",
            "cpu": "4",
            "memory": "16Gi",
            "accelerator": "GPU",
            "image": "ghcr.io/amdresearch/aup-course-llm:v1.3.1-TheRock",
            "accelerator_keys": GFX1151_ACCELERATORS
        },
        "Tutorial-HIP-Intro": {
            "name": "Tutorial-HIP-Intro",
            "group": "TUTORIAL", 
            "description": "HIP Introduction Tutorial",
            "sub_description": "Suitable for learning HIP programming",
            "cpu": "4",
            "memory": "8Gi",
            "accelerator": "GPU",
            "image": "ghcr.io/amdresearch/aup-tutorial-hip-intro:v1.0.1",
            "accelerator_keys": GPU_ACCELERATORS
        },
        "Tutorial-LLM-Lemonade": {
            "name": "Tutorial-LLM-Lemonade",
            "group": "TUTORIAL", 
            "description": "LLM Lemonade Tutorial",
            "sub_description": "Suitable for LLM hands-on exercises",
            "cpu": "4",
            "memory": "8Gi",
            "accelerator": "GPU",
            "image": "ghcr.io/amdresearch/aup-tutorial-llm-lemonade:v1.3",
            "accelerator_keys": GFX1151_ACCELERATORS
        },
        "Tutorial-LLM-Ollama": {
        "name": "Tutorial-LLM-Ollama",
        "group": "TUTORIAL",
        "description": "LLM Ollama Tutorial",
        "sub_description": "Suitable for LLM hands-on exercises",
        "cpu": "4",
        "memory": "8Gi",
        "accelerator": "GPU",
        "image": "ghcr.io/amdresearch/aup-tutorial-llm-ollama:v1.0",
        "accelerator_keys": GFX1151_ACCELERATORS
    },
        "Tutorial-NPU-Resnet": {
            "name": "Tutorial-NPU-Resnet",
            "group": "TUTORIAL", 
            "description": "NPU ResNet Tutorial",
            "sub_description": "Suitable for ResNet inference on NPU",
            "cpu": "4",
            "memory": "8Gi",
            "accelerator": "NPU",
            "image": "ghcr.io/amdresearch/aup-tutorial-npu-resnet:v1.4-onnx-notebook",
            "accelerator_keys": NPU_ACCELERATORS
        },
        "none": {
            "name": "cpu",
            "group": "OTHERS",
            "description": "No team info",
            "sub_description": "Basic Environment | Limited Resources",
            "cpu": "2",
            "memory": "4Gi",
            "image": "ghcr.io/amdresearch/aup-cpu-notebook:v1.0"
        },
        "ROSCON2025-GPU": {
        "name": "ROSCON2025-GPU",
        "group": "ROSCON2025",
        "description": "GPU Workshop for RosCon2025",
        "sub_description": "Suitable for experiments with AMD GPU",
        "cpu": "4",
        "memory": "16Gi",
        "accelerator": "GPU",
        "image": "ghcr.io/amdresearch/aup-roscon2025-gpu:v1.0",
        "accelerator_keys": GFX1151_ACCELERATORS
        },
        "ROSCON2025-NPU": {
        "name": "ROSCON2025-NPU",
        "group": "ROSCON2025",
        "description": "NPU Workshop for RosCon2025",
        "sub_description": "Suitable for experiments with AMD XDNA NPU",
        "cpu": "4",
        "memory": "16Gi",
        "accelerator": "NPU",
        "image": "ghcr.io/amdresearch/aup-roscon2025-npu:v1.0",
        "accelerator_keys": GFX1151_ACCELERATORS
        },
        "ROSCON2025-DIGIT": {
        "name": "ROSCON2025-DIGIT",
        "group": "ROSCON2025",
        "description": "Digital_Twin_Handson Workshop for RosCon2025",
        "sub_description": "Suitable for experiments with AMD GPU",
        "cpu": "4",
        "memory": "16Gi",
        "accelerator": "GPU",
        "image": "ghcr.io/amdresearch/aup-roscon2025-digit:v1.0",
        "accelerator_keys": GFX1151_ACCELERATORS
        },
    };

// Fetch available resources from the backend
async function fetchAvailableResources() {
    // Check if resources are injected from the backend
    if (window.AVAILABLE_RESOURCES) {
        return window.AVAILABLE_RESOURCES;
    }
    
    // If not, try to read from hidden element
    const resourcesElement = document.getElementById('available-resources-data');
    if (resourcesElement) {
        try {
            return JSON.parse(resourcesElement.textContent);
        } catch (e) {
            console.error('Failed to parse available resources:', e);
        }
    }
    
    // Simulate API delay (for development)
    await new Promise(resolve => setTimeout(resolve, 500));
    
    // Return all resources by default (for development/testing)
    return ["cpu", "rocm", "torch", "ryzenai-onnx"];
}

function formatResourceDescription(cpu, memory, accelerator = null) {
    let resources = `${cpu} CPU, ${memory}GB Memory`;
    if (accelerator) {
        resources += `, 1 ${accelerator}`;
    }
    return resources;
}

function createResourceHTML(resource) {
    const resourceString = formatResourceDescription(resource.cpu, resource.memory, resource.accelerator);

    let gpuSelectionHTML = '';
    if (resource.accelerator_keys && resource.accelerator_keys.length > 0) {
        // Build GPU options dynamically from backend accelerator config
        const gpuOptions = buildGpuOptions(resource.accelerator_keys);
        gpuSelectionHTML = `
            <div id="gpu_selection_${resource.name}" class="gpu-selection">
                <h6>Choose ${resource.accelerator} Node:</h6>
                <div class="gpu-options-container">
                    ${Object.entries(gpuOptions).map(([gpuKey, gpuOption], index) => `
                        <div class="gpu-option" onclick="selectGpuOption('${resource.name}', '${gpuKey}', event);">
                            <input type="radio"
                                   id="gpu_${resource.name}_${gpuKey}"
                                   name="gpu_selection_${resource.name}"
                                   value="${gpuKey}"
                                   ${index === 0 ? 'checked' : ''}
                                   onclick="event.stopPropagation();">
                            <div class="gpu-option-details">
                                <div class="gpu-option-name">${gpuOption.display_name}</div>
                                <div class="gpu-option-desc">${gpuOption.description}</div>
                            </div>
                        </div>
                    `).join('')}
                </div>
            </div>
        `;
    }
    
    return `
        <div class="resource-container" 
             style="margin-bottom: 14px; padding: 16px; border: 1px solid #e0e0e0; border-radius: 10px; display: flex; flex-direction: column; background: white; box-shadow: 0 1px 3px rgba(0,0,0,0.05); cursor: pointer;" 
             onmouseover="this.style.backgroundColor='#f9fafb';" 
             onmouseout="this.style.backgroundColor='white';" 
             onclick="selectResource('${resource.name}');">
            
            <div style="display: flex; align-items: center;">
                <input type="radio" 
                       id="${resource.name}" 
                       name="resource_type" 
                       value="${resource.name}" 
                       style="margin-right: 15px; width: 16px; height: 16px; accent-color: #6c7a89;"
                       onchange="toggleGpuSelection('${resource.name}');">
                
                <div style="flex: 1;">
                    <strong style="display: block; font-size: 15px; color: #2c3e50; margin-bottom: 4px;">${resource.description}</strong>
                    <div style="display: flex; align-items: center; gap: 8px; font-size: 13px;">
                        <span class="env-desc" style="color: #34495e;">${resource.sub_description}</span>
                        <span class="dot" style="color: #95a5a6;">â€¢</span>
                        <span class="resource-tag" style="color: #c65d21; background: #fff5eb; padding: 2px 8px; border-radius: 3px; border: 1px solid #fbe5d6;">${resourceString}</span>
                    </div>
                </div>
            </div>
            
            ${gpuSelectionHTML}
        </div>
    `;
}

    async function loadResources() {
        try {
            // Fetch resources and quota info in parallel
            const [availableResourceNames, quotaInfo] = await Promise.all([
                fetchAvailableResources(),
                fetchUserQuota()
            ]);
            const resourceListElement = document.getElementById('resourceList');

            if (availableResourceNames.length === 0) {
                document.getElementById('noResources').style.display = 'block';
            } else {
                // æŒ‰ COURSE / TUTORIAL / OTHERS åˆ†ç»„
                const groups = {
                    "ROSCON2025": [],
                    "COURSE": [],
                    "TUTORIAL": [],
                    "OTHERS": []
                };

                availableResourceNames.forEach(resourceName => {
                    const resource = RESOURCE_SPECS[resourceName];
                    if (resource) {
                        const group = resource.group || "OTHERS";
                        groups[group].push(resource);
                    }
                });

                let resourcesHTML = "";

                Object.keys(groups).forEach(groupName => {
                    const groupResources = groups[groupName];
                    if (groupResources.length === 0) return;

                    resourcesHTML += `
                    <div class="resource-category collapsed" id="${groupName}-category">
                        <div class="resource-category-header" onclick="toggleCategory('${groupName}-category')">
                            <h5 style="font-size: 18px;">ðŸ“‚ ${groupName}</h5>
                            <span class="collapse-icon">â–¼</span>
                        </div>
                        <div class="collapsible-content">
                            ${groupResources.map(resource => createResourceHTML(resource)).join('')}
                        </div>
                    </div>
                `;
                });

                resourceListElement.innerHTML = resourcesHTML;

            // Default select first resource
                if (availableResourceNames.length > 0) {
                    const firstResource = availableResourceNames[0];
                    document.getElementById(firstResource).checked = true;
                    toggleGpuSelection(firstResource);
                }
            }

            document.getElementById('resourceForm').style.display = 'block';

            // Hide runtime selector in single-node mode
            if (window.SINGLE_NODE_MODE) {
                const runtimeContainer = document.getElementById('runtimeContainer');
                const runtimeInput = document.getElementById('runtimeInput');
                if (runtimeContainer) {
                    runtimeContainer.style.display = 'none';
                }
                // Set a large default runtime value for single-node mode and disable the input
                if (runtimeInput) {
                    runtimeInput.value = 99999;
                    runtimeInput.disabled = true;  // Disable to prevent validation issues
                }
            }
        } catch (error) {
            console.error('Error loading resources:', error);
            document.getElementById('noResources').style.display = 'block';
            document.getElementById('resourceForm').style.display = 'block';
        } finally {
            document.getElementById('loading').style.display = 'none';
        }
    }

function selectResource(resourceName) {
    // Select the radio button
    document.getElementById(resourceName).checked = true;

    // Toggle GPU selection visibility
    toggleGpuSelection(resourceName);

    // Update quota cost preview
    onResourceSelected(resourceName);

    // Enable the Start button
    enableStartButton();
}

function toggleGpuSelection(selectedResource) {
    // Hide all GPU selection panels
    const allGpuSelections = document.querySelectorAll('.gpu-selection');
    allGpuSelections.forEach(selection => {
        selection.style.display = 'none';
    });

    // Show GPU selection for the selected resource
    const selectedGpuSelection = document.getElementById('gpu_selection_' + selectedResource);
    if (selectedGpuSelection) {
        selectedGpuSelection.style.display = 'block';

        // Ensure first GPU option is selected by default
        const firstGpuOption = selectedGpuSelection.querySelector('input[type="radio"]');
        if (firstGpuOption && !selectedGpuSelection.querySelector('input[type="radio"]:checked')) {
            firstGpuOption.checked = true;
        }

        // Update accelerator type based on selected/default GPU option
        const checkedGpuOption = selectedGpuSelection.querySelector('input[type="radio"]:checked');
        if (checkedGpuOption) {
            // Extract GPU key from radio id (format: gpu_resourceName_gpuKey)
            const parts = checkedGpuOption.id.split('_');
            selectedAcceleratorType = parts[parts.length - 1];
        }
    } else {
        // No GPU options for this resource, use 'cpu'
        selectedAcceleratorType = 'cpu';
    }

    // Update quota preview with new accelerator type
    updateQuotaCostPreview();
}

function selectGpuOption(resourceName, gpuKey, event) {
    event.stopPropagation();

    // Select the GPU radio button
    document.getElementById('gpu_' + resourceName + '_' + gpuKey).checked = true;

    // Update selected accelerator type for quota calculation
    selectedAcceleratorType = gpuKey;
    updateQuotaCostPreview();
}

// Toggle category collapse/expand
function toggleCategory(categoryId) {
    const category = document.getElementById(categoryId);
    if (category) {
        const isCurrentlyCollapsed = category.classList.contains('collapsed');
        
        // First collapse all categories
        const allCategories = document.querySelectorAll('.resource-category');
        allCategories.forEach(cat => {
            cat.classList.add('collapsed');
            const catId = cat.id;
            localStorage.setItem(catId + '-collapsed', true);
        });
        
        // Then expand the clicked one if it was collapsed
        if (isCurrentlyCollapsed) {
            category.classList.remove('collapsed');
            localStorage.setItem(categoryId + '-collapsed', false);
        }
    }
}

// Set initial category states
function setInitialCategoryStates() {
    // Only need to ensure the CPU category is expanded
    const cpuCategory = document.getElementById('cpu-category');
    if (cpuCategory) {
        cpuCategory.classList.remove('collapsed');
        localStorage.setItem('cpu-category-collapsed', false);
    }
    
    // Set GPU and NPU to collapsed in localStorage
    localStorage.setItem('gpu-category-collapsed', true);
    localStorage.setItem('npu-category-collapsed', true);
}

// Clear selection when clicking elsewhere on the page
document.addEventListener('click', function(event) {
    // Check if the click is outside any gpu-option, resource-container, or scroll-to-bottom button
    if (!event.target.closest('.gpu-option') && 
        !event.target.closest('.resource-container') && 
        !event.target.closest('.scroll-to-bottom')) {
        
        // Clear all radio button selections
        document.querySelectorAll('input[type="radio"]').forEach(radio => {
            radio.checked = false;
        });
        
        // Hide all GPU selection panels
        document.querySelectorAll('.gpu-selection').forEach(selection => {
            selection.style.display = 'none';
        });
        
        // Disable the Start button
        disableStartButton();
    }
});

// Function to enable the Start button
function enableStartButton() {
    const startButton = document.getElementById('startButton');
    if (startButton) {
        startButton.disabled = false;
        startButton.style.opacity = '1';
        startButton.style.cursor = 'pointer';
    }
}

// Function to disable the Start button
function disableStartButton() {
    const startButton = document.getElementById('startButton');
    if (startButton) {
        startButton.disabled = true;
        startButton.style.opacity = '0.5';
        startButton.style.cursor = 'not-allowed';
    }
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', function() {
    loadResources();
    
    // Set initial category states immediately after resources are loaded
    document.getElementById('resourceForm').addEventListener('DOMNodeInserted', function handler() {
        if (document.getElementById('cpu-category')) {
            setInitialCategoryStates();
            // Remove this event listener after it's executed once
            document.getElementById('resourceForm').removeEventListener('DOMNodeInserted', handler);
        }
    });
    
    // Add event listeners to all radio buttons to enable the Start button
    document.addEventListener('change', function(event) {
        if (event.target.type === 'radio') {
            enableStartButton();
        }
    });
    
    // Scroll to bottom button functionality
    const scrollToBottomBtn = document.getElementById('scrollToBottom');
    
    // Show button when page is scrolled down
    window.addEventListener('scroll', function() {
        // Check if page height exceeds viewport height
        if (document.body.scrollHeight > window.innerHeight) {
            // Show button when scrolled down a bit
            if (window.scrollY > 100) {
                scrollToBottomBtn.classList.add('visible');
            } else {
                scrollToBottomBtn.classList.remove('visible');
            }
        }
    });
    
    // Scroll to bottom when button is clicked
    scrollToBottomBtn.addEventListener('click', function() {
        window.scrollTo({
            top: document.body.scrollHeight,
            behavior: 'smooth'
        });
    });
    
    // Initial check if scroll button should be visible
    if (document.body.scrollHeight > window.innerHeight) {
        if (window.scrollY > 100) {
            scrollToBottomBtn.classList.add('visible');
        }
    }
});
</script>
</body>
</html>
